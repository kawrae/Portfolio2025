import { useEffect, useState } from 'react';
import * as THREE from 'three';
import { useMemo, useContext, createContext, useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { useGLTF, Merged, RenderTexture, PerspectiveCamera, Text } from '@react-three/drei';
import { useLayoutEffect } from 'react';

THREE.ColorManagement.legacyMode = false;

/*
The following was auto-generated by: npx gltfjsx computers.glb --transform --instance
By using the --instance flag it detects similar geometry and instances it, thereby minimizing draw-calls

Author: Rafael Rodrigues (https://sketchfab.com/RafaelBR873D)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/old-computers-7bb6e720499a467b8e0427451d180063
Title: Old Computers
*/

const context = createContext();

export function Instances({ children, ...props }) {
	const { scene } = useGLTF('/models/notre-damn_8k.glb');
	console.log('GLTF Scene:', scene);

	const instances = useMemo(() => ({
		NotreDame: scene,
	}), [scene]);

	return (
		<group {...props}>
			<context.Provider value={instances}>
				{children}
			</context.Provider>
		</group>
	);
}


export function Computers(props) {
	const instances = useContext(context);
	const modelRef = useRef();


	useLayoutEffect(() => {
		if (!modelRef.current) return;
	
		const model = modelRef.current;
	
		const box = new THREE.Box3().setFromObject(model);
		const center = new THREE.Vector3();
		box.getCenter(center);
		model.position.sub(center);
	
		model.traverse((child) => {
			if (child.isMesh && child.material && child.material.color) {
				child.material = child.material.clone();
				child.material.color.multiplyScalar(0.85);
				child.material.roughness = 0.5;
				child.material.metalness = 0.2;
			}
		});
	}, []);

	return (
		<group {...props} dispose={null}>
			<primitive
				ref={modelRef}
				object={useMemo(() => instances.NotreDame.clone(true), [instances])}
				scale={4.5}
				rotation={[0, -Math.PI / 2, 0]}
				position={[0, 0, 0]}
			/>
		</group>
	);
}


/* This component renders a monitor (taken out of the gltf model)
   It renders a custom scene into a texture and projects it onto monitors screen */
function Screen({ frame, panel, children, ...props }) {
	const { nodes, materials } = useGLTF('/models/computers_1-transformed.glb');

	return (
		<group {...props}>
			<mesh castShadow receiveShadow geometry={nodes[frame].geometry} material={materials.Texture} />
			<mesh geometry={nodes[panel].geometry}>
				<meshBasicMaterial toneMapped={false}>
					<RenderTexture width={512} height={512} attach="map" anisotropy={16}>
						{children}
					</RenderTexture>
				</meshBasicMaterial>
			</mesh>
		</group>
	)
}

/* Renders a monitor with some text */
function ScreenText({ invert, x = 0, y = 1.2, isOn = false, ...props }) {
	const textRef = useRef();
	const rand = Math.random() * 10000;

	useFrame((state) => {
		if (textRef.current) {
			textRef.current.position.x = x + Math.sin(rand + state.clock.elapsedTime / 4) * 8;
		}
	});

	return (
		<Screen {...props}>
			<PerspectiveCamera makeDefault manual aspect={1 / 1} position={[0, 0, 15]} />
			<color attach="background" args={[!isOn ? 'black' : invert ? 'black' : '#5aff08']} />
			<ambientLight intensity={0.5} />
			<directionalLight position={[10, 10, 5]} />
			{isOn && (
				<Text
					font="/fonts/poppins-bold.woff"
					position={[x, y, 0]}
					ref={textRef}
					fontSize={4}
					letterSpacing={-0.1}
					color={!invert ? 'black' : '#5aff08'}
				>
					coreyblack
				</Text>
			)}
		</Screen>
	);
}

function TerminalSequencePowerOn({
	fontSize = 0.1,
	lineHeight = 1.2,
	position = [-2.45, 0.9, 0],
	color = '#5aff08',
	onMonitorPower = () => { }
}) {
	const linesToType = [
		'> monitor_01: ON',
		'> monitor_02: ON',
		'> monitor_03: ON',
		'> monitor_04: ON',
		'> monitor_05: ON',
		'> monitor_06: ON',
		'> monitor_07: ON',
		'> monitor_08: ON',
		'> status: LINKED'
	];

	const maxVisibleLines = 7;
	const [typedLines, setTypedLines] = useState([]);
	const [currentLine, setCurrentLine] = useState('');
	const [lineIndex, setLineIndex] = useState(0);
	const [charIndex, setCharIndex] = useState(0);
	const [cursorVisible, setCursorVisible] = useState(true);

	useEffect(() => {
		if (lineIndex >= linesToType.length) return;

		const currentTarget = linesToType[lineIndex];
		let timeout;

		if (charIndex < currentTarget.length) {
			timeout = setTimeout(() => {
				setCurrentLine(prev => prev + currentTarget[charIndex]);
				setCharIndex(i => i + 1);
			}, 25);
		} else {
			timeout = setTimeout(() => {
				setTypedLines(prev => {
					const updated = [...prev, currentTarget];
					return updated.length > maxVisibleLines ? updated.slice(1) : updated;
				});
				setCurrentLine('');
				setCharIndex(0);

				// Notify when a monitor turns on
				if (currentTarget.startsWith('> monitor_')) {
					const match = currentTarget.match(/monitor_(\d+): ON/);
					if (match) {
						onMonitorPower(parseInt(match[1], 10));
					}
				}

				setLineIndex(i => i + 1);
			}, 600);
		}

		return () => clearTimeout(timeout);
	}, [charIndex, lineIndex]);

	useEffect(() => {
		const cursorTimer = setInterval(() => {
			setCursorVisible(v => !v);
		}, 500);
		return () => clearInterval(cursorTimer);
	}, []);

	let all = [...typedLines];
	if (currentLine) {
		all = [...all, cursorVisible ? currentLine + ' █' : currentLine];
	} else if (lineIndex >= linesToType.length) {
		all = [...all, cursorVisible ? '> █' : '>  '];
	}
	if (all.length > maxVisibleLines) {
		all = all.slice(all.length - maxVisibleLines);
	}

	return (
		<Text
			font="/fonts/roboto-mono-regular.ttf"
			fontSize={fontSize}
			lineHeight={lineHeight}
			anchorX="left"
			anchorY="top"
			position={position}
			color={color}
		>
			{all.join('\n')}
		</Text>
	);
}

function ScreenCentre(props) {
	return (
		<Screen {...props}>
			<PerspectiveCamera makeDefault manual aspect={1 / 1} position={[0, 0, 6]} />
			<color attach="background" args={['black']} />
			<ambientLight intensity={1.2} />
			{props.bootComplete && <TerminalSequencePowerOn onMonitorPower={props.onMonitorPower} />}
		</Screen>
	);
}

// Renders flashing LED's
function Leds({ instances }) {
	const ref = useRef();
	const { nodes } = useGLTF('/models/computers_1-transformed.glb');

	useMemo(() => {
		nodes.Sphere.material = new THREE.MeshBasicMaterial()
		nodes.Sphere.material.toneMapped = false
	}, []);

	useFrame((state) => {
		ref.current.children.forEach((instance) => {
			const rand = Math.abs(2 + instance.position.x)
			const t = Math.round((1 + Math.sin(rand * 10000 + state.clock.elapsedTime * rand)) / 2)
			instance.color.setRGB(0, t * 1.1, t)
		})
	});

	return (
		<group ref={ref}>
			<instances.Sphere position={[-0.41, 1.1, -2.21]} scale={0.005} color={[1, 2, 1]} />
			<instances.Sphere position={[0.59, 1.32, -2.22]} scale={0.005} color={[1, 2, 1]} />
			<instances.Sphere position={[1.77, 1.91, -1.17]} scale={0.005} color={[1, 2, 1]} />
			<instances.Sphere position={[2.44, 1.1, -0.79]} scale={0.005} color={[1, 2, 1]} />
			<instances.Sphere position={[4.87, 3.8, -0.1]} scale={0.005} color={[1, 2, 1]} />
			<instances.Sphere position={[1.93, 3.8, -3.69]} scale={0.005} color={[1, 2, 1]} />
			<instances.Sphere position={[-2.35, 3.8, -3.48]} scale={0.005} color={[1, 2, 1]} />
			<instances.Sphere position={[-4.71, 4.59, -1.81]} scale={0.005} color={[1, 2, 1]} />
			<instances.Sphere position={[-3.03, 2.85, 1.19]} scale={0.005} color={[1, 2, 1]} />
			<instances.Sphere position={[-1.21, 1.73, -1.49]} scale={0.005} color={[1, 2, 1]} />
		</group>
	)
}
